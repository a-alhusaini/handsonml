# Housing

```elixir
Mix.install([
  {:nx, "~> 0.4"},
  {:explorer, "~> 0.4"},
  {:exla, "~> 0.4"},
  {:vega_lite, "~> 0.1.5"},
  {:kino_vega_lite, "~> 0.1.1"},
  {:httpoison, "~> 1.8"}
])
```

## Fetching The Dataset

```elixir
defmodule FetchDataSet do
  @download_root "https://raw.githubusercontent.com/ageron/handson-ml2/master/"
  @housing_path Path.join(["ch2", "datasets", "housing"])
  @housing_url @download_root <> "datasets/housing/housing.tgz"

  def run(housing_url \\ @housing_url, housing_path \\ @housing_path) do
    if not File.dir?(housing_path) do
      File.mkdir_p!(housing_path)
    end

    resp = HTTPoison.get!(housing_url)
    tgz_path = Path.join([housing_path, "housing.tgz"])
    File.write!(tgz_path, resp.body)
    :erl_tar.extract(tgz_path, [:compressed, cwd: housing_path])

    IO.puts("Download successful")
  end
end

FetchDataSet.run()
```

## Creating a test set

The issue with creating a dataset by picking random values from the data is that there is a chance of a sampling bias occurring.

To avoid this, prefer creating the test set with stratified shuffling. Stratified shuffling is when you seperate a certain attribute into a few categories and pick 20% of each category of that attribute and use that to represent your test set.

This approach is valid in this situation. I will use the median income attribute for this stratified shuffle.

## Stratified Shuffle Implementation

```elixir
defmodule StratifiedShuffle do
  require Explorer.DataFrame

  alias Explorer.DataFrame
  alias Explorer.Series

  def run(original_df, category_column) do
    categories = DataFrame.distinct(original_df, [category_column])
    categories = Series.to_list(categories[category_column])

    %{training_df: train_set, testing_df: test_set} =
      Enum.reduce(
        categories,
        %{
          training_df: original_df,
          testing_df: original_df |> DataFrame.slice([0, 0])
        },
        fn category, %{training_df: original_df, testing_df: testing_df} ->
          testing_chunk =
            DataFrame.filter_with(original_df, fn row ->
              Series.equal(row[category_column], category)
            end)
            |> DataFrame.sample(0.2, seed: 42)

          %{
            training_df: original_df,
            testing_df: DataFrame.concat_rows(testing_df, testing_chunk)
          }
        end
      )

    remove_test_samples_from_training_set(train_set, test_set)
  end

  defp remove_test_samples_from_training_set(train_set, test_set) do
    train_mapset = DataFrame.to_rows(train_set) |> MapSet.new()
    test_mapset = DataFrame.to_rows(test_set) |> MapSet.new()

    train_set =
      MapSet.difference(train_mapset, test_mapset)
      |> MapSet.to_list()
      |> Explorer.DataFrame.new()

    {train_set, test_set}
  end
end
```

## train/test split implementation

```elixir
defmodule SplitTrainTest do
  require Explorer.DataFrame

  alias Explorer.DataFrame

  def run() do
    full_set = DataFrame.from_csv!("./ch2/datasets/housing/housing.csv")

    # add income_categorization to dataset
    full_set =
      DataFrame.put(
        full_set,
        "income_cat",
        Enum.map(
          full_set["median_income"]
          |> Explorer.Series.to_enum(),
          fn income ->
            cond do
              income < 1.5 -> 1
              income < 3.0 -> 2
              income < 4.5 -> 3
              income < 6.0 -> 4
              true -> 5
            end
          end
        )
      )

    StratifiedShuffle.run(full_set, "income_cat")
  end
end

{train_split, _} = SplitTrainTest.run()
```

<!-- livebook:{"attrs":{"chart_title":null,"height":null,"layers":[{"chart_type":"point","color_field":null,"color_field_aggregate":null,"color_field_bin":false,"color_field_scale_scheme":null,"color_field_type":null,"data_variable":"train_split","x_field":"latitude","x_field_aggregate":null,"x_field_bin":false,"x_field_scale_type":null,"x_field_type":"quantitative","y_field":"latitude","y_field_aggregate":null,"y_field_bin":false,"y_field_scale_type":null,"y_field_type":"quantitative"}],"vl_alias":"Elixir.VegaLite","width":null},"chunks":null,"kind":"Elixir.KinoVegaLite.ChartCell","livebook_object":"smart_cell"} -->

```elixir
VegaLite.new()
|> VegaLite.data_from_values(train_split, only: ["latitude"])
|> VegaLite.mark(:point)
|> VegaLite.encode_field(:x, "latitude", type: :quantitative)
|> VegaLite.encode_field(:y, "latitude", type: :quantitative)
```
